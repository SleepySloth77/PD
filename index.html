<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Multi-color Boundary Defense Simulation (Frontline Lock)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{margin:0;height:100vh;display:flex;gap:18px;background:#071827;color:#e6eef6;font-family:Inter,system-ui;padding:18px}
  .panel{width:380px;background:#0f1720;padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
  label{font-size:12px;color:#9aa3b2;display:block;margin-top:8px}
  input[type=range], select{width:100%}
  button{background:#15324a;border:none;color:#e6eef6;padding:8px 10px;border-radius:8px;cursor:pointer;margin-right:6px}
  button.secondary{background:#0b2a3a}
  #world{background:#08131b;display:block;border-radius:8px}
  .small{font-size:12px;color:#9aa3b2}
</style>
</head>
<body>
  <div class="panel">
    <h1>Multi-color Boundary Defense (Frontline Lock)</h1>

    <label>Grid size: <span id="sizeLbl">100</span></label>
    <input id="sizeRange" type="range" min="20" max="200" value="100">

    <label>Base reproduction probability</label>
    <input id="reproProb" type="range" min="0" max="0.2" step="0.005" value="0.02">
    <div id="reproProbVal">0.02</div>

    <label>Contest sharpness</label>
    <input id="sharpness" type="range" min="0.1" max="5" step="0.1" value="1">
    <div id="sharpVal">1</div>

    <label>Star side</label>
    <select id="starSide">
      <option value="left">Left</option>
      <option value="right">Right</option>
      <option value="top">Top</option>
      <option value="bottom">Bottom</option>
    </select>

    <label>Star attraction multiplier</label>
    <input id="starBias" type="range" min="1" max="5" step="0.1" value="2">
    <div id="starBiasVal">2</div>

    <label>Frontline freeze depth (layers behind boundary locked)</label>
    <input id="freezeDepth" type="range" min="1" max="5" step="1" value="2">
    <div class="small">Depth: <strong id="freezeVal">2</strong></div>

    <label>Power Scores</label>
    <div class="small">Green <input id="p0" type="range" min="0" max="100" value="50"> <span id="p0v">50</span></div>
    <div class="small">Blue  <input id="p1" type="range" min="0" max="100" value="45"> <span id="p1v">45</span></div>
    <div class="small">Yellow<input id="p2" type="range" min="0" max="100" value="40"> <span id="p2v">40</span></div>
    <div class="small">Red   <input id="p3" type="range" min="0" max="100" value="55"> <span id="p3v">55</span></div>
    <div class="small">Pink  <input id="p4" type="range" min="0" max="100" value="30"> <span id="p4v">30</span></div>

    <label>Initial Counts</label>
    <div class="small">Green <input id="c0" type="range" min="1" max="500" value="100"> <span id="c0v">100</span></div>
    <div class="small">Blue  <input id="c1" type="range" min="1" max="500" value="100"> <span id="c1v">100</span></div>
    <div class="small">Yellow<input id="c2" type="range" min="1" max="500" value="100"> <span id="c2v">100</span></div>
    <div class="small">Red   <input id="c3" type="range" min="1" max="500" value="100"> <span id="c3v">100</span></div>
    <div class="small">Pink  <input id="c4" type="range" min="1" max="500" value="100"> <span id="c4v">100</span></div>

    <div style="margin-top:10px">
      <button id="startBtn">Start</button>
      <button id="stopBtn" class="secondary">Stop</button>
      <button id="randomBtn" class="secondary">Seed Clusters</button>
      <button id="clearBtn" class="secondary">Clear</button>
    </div>

    <div id="tickDisp" style="margin-top:10px;font-size:12px;color:#9aa3b2">Tick: 0</div>
    <div class="small" style="margin-top:8px">Tip: locked frontline zones glow faintly. Click canvas to cycle occupants on a cell.</div>
  </div>

  <canvas id="world" width="700" height="700"></canvas>

<script>
(() => {
  const colors = [null,'#2ecc71','#2ea3ff','#f6e05e','#ff6b6b','#ff7ab6'];
  let cols=100, rows=100, cellSize=7;
  let grid=[], tick=0, running=false, interval=null;
  const canvas=document.getElementById('world'), ctx=canvas.getContext('2d');

  const sizeRange=document.getElementById('sizeRange'), sizeLbl=document.getElementById('sizeLbl');
  const reproProb=document.getElementById('reproProb'), reproProbVal=document.getElementById('reproProbVal');
  const sharpness=document.getElementById('sharpness'), sharpVal=document.getElementById('sharpVal');
  const starSide=document.getElementById('starSide');
  const starBias=document.getElementById('starBias'), starBiasVal=document.getElementById('starBiasVal');
  const freezeDepth=document.getElementById('freezeDepth'), freezeVal=document.getElementById('freezeVal');

  function resizeGrid(n){ cols=n; rows=n; cellSize = Math.max(1, Math.floor(700/n)); canvas.width = cellSize*cols; canvas.height = cellSize*rows; initGrid(); }
  function initGrid(){ grid = new Array(rows).fill(0).map(()=>new Array(cols).fill(0)); tick=0; draw(); }

  function clusterSpawn(){
    initGrid();
    const centers=[
      [Math.floor(cols*0.15),Math.floor(rows*0.15)],
      [Math.floor(cols*0.85),Math.floor(rows*0.15)],
      [Math.floor(cols*0.15),Math.floor(rows*0.85)],
      [Math.floor(cols*0.85),Math.floor(rows*0.85)],
      [Math.floor(cols*0.5),Math.floor(rows*0.5)]
    ];

    const counts = [
      parseInt(document.getElementById('c0').value),
      parseInt(document.getElementById('c1').value),
      parseInt(document.getElementById('c2').value),
      parseInt(document.getElementById('c3').value),
      parseInt(document.getElementById('c4').value)
    ];

    for(let s=1;s<=5;s++){
      const [cx,cy] = centers[s-1];
      let placed = 0;
      while(placed < counts[s-1]){
        const x = cx + Math.floor(Math.random()*11 - 5);
        const y = cy + Math.floor(Math.random()*11 - 5);
        if(x>=0 && y>=0 && x<cols && y<rows && grid[y][x]===0){
          grid[y][x] = s;
          placed++;
        }
      }
    }

    draw();
  }

  function clearGrid(){ initGrid(); }

  function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
    const side = starSide.value; ctx.fillStyle = 'rgba(255,255,255,0.04)';
    if(side==='left') ctx.fillRect(0,0,canvas.width*0.15,canvas.height);
    if(side==='right') ctx.fillRect(canvas.width*0.85,0,canvas.width*0.15,canvas.height);
    if(side==='top') ctx.fillRect(0,0,canvas.width,canvas.height*0.15);
    if(side==='bottom') ctx.fillRect(0,canvas.height*0.85,canvas.width,canvas.height*0.15);

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const v = grid[y][x];
        if(v){ ctx.fillStyle = colors[v]; ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize); }
      }
    }

    if(lastLocked && lastLocked.size>0){ ctx.fillStyle = 'rgba(255,255,255,0.06)';
      lastLocked.forEach(k=>{ const [x,y] = k.split(',').map(Number); ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize); });
      ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = Math.max(1, cellSize*0.08);
      lastBoundary.forEach(k=>{ const [x,y] = k.split(',').map(Number); ctx.strokeRect(x*cellSize+0.5, y*cellSize+0.5, cellSize-1, cellSize-1); });
    }
  }

  function inBounds(x,y){ return x>=0 && y>=0 && x<cols && y<rows; }

  function computeBoundariesAndLocks(depth){
    const boundary = new Set();
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const v = grid[y][x];
        if(!v) continue;
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dy] of dirs){
          const nx=x+dx, ny=y+dy; if(!inBounds(nx,ny)) continue; const o=grid[ny][nx];
          if(o && o!==v){ boundary.add(`${x},${y}`); break; }
        }
      }
    }

    const locked = new Set();
    const visited = new Set();
    const q = [];
    boundary.forEach(k=>{ const parts=k.split(',').map(Number); q.push({x:parts[0], y:parts[1], d:0}); visited.add(k); locked.add(k); });

    while(q.length){ const cur = q.shift(); if(cur.d >= depth) continue; const v = grid[cur.y][cur.x];
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){ const nx=cur.x+dx, ny=cur.y+dy; if(!inBounds(nx,ny)) continue; const key = `${nx},${ny}`;
        if(visited.has(key)) continue; if(grid[ny][nx]===v){ visited.add(key); locked.add(key); q.push({x:nx,y:ny,d:cur.d+1}); }
      }
    }

    return {boundary, locked};
  }

  let lastLocked = new Set();
  let lastBoundary = new Set();

  function step(){
    const newGrid = grid.map(r=>r.slice());
    const baseProb = parseFloat(reproProb.value);
    const powers = [0, ...Array(5)].map((_,i)=> i>0 ? parseFloat(document.getElementById('p'+(i-1)).value) : 0 );
    const avgPower = (powers.slice(1).reduce((a,b)=>a+b,0) / 5);
    const sharp = parseFloat(sharpness.value);
    const bias = parseFloat(starBias.value);
    const depth = parseInt(freezeDepth.value,10);

    const {boundary, locked} = computeBoundariesAndLocks(depth);
    lastLocked = locked; lastBoundary = boundary;

    const processedPairs = new Set();
    boundary.forEach(k => {
      const [x,y] = k.split(',').map(Number);
      const v = grid[y][x];
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy; if(!inBounds(nx,ny)) continue; const o = grid[ny][nx];
        if(!o || o===v) continue; 
        const pairKey = (x<nx || (x===nx && y<ny)) ? `${x},${y}-${nx},${ny}` : `${nx},${ny}-${x},${y}`;
        if(processedPairs.has(pairKey)) continue; 
        const pv = powers[v]; const po = powers[o];
        const win = 1 / (1 + Math.exp(-sharp*(pv-po)/20));
        if(Math.random() < win){ newGrid[ny][nx] = v; }
        else { newGrid[y][x] = o; }
        processedPairs.add(pairKey);
      }
    });

    const spawns = [];
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const v = grid[y][x]; if(!v) continue;
        const key = `${x},${y}`;
        if(locked.has(key)) continue;

        let prob = baseProb;
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dy] of dirs){
          const nx = x+dx, ny = y+dy; if(!inBounds(nx,ny)) continue; if(grid[ny][nx] !== 0) continue;
          let dirProb = prob;
          if(powers[v] > avgPower){
            if((starSide.value==='left' && dx<0) || (starSide.value==='right' && dx>0) || (starSide.value==='top' && dy<0) || (starSide.value==='bottom' && dy>0)){
              dirProb *= bias;
            }
          }
          if(Math.random() < dirProb) spawns.push([nx,ny,v]);
        }
      }
    }
    for(const [x,y,v] of spawns){ if(newGrid[y][x] === 0) newGrid[y][x] = v; }

    grid = newGrid; tick++; document.getElementById('tickDisp').textContent = 'Tick: ' + tick; draw();
  }

  document.getElementById('startBtn').onclick = ()=>{ if(!running){ running = true; interval = setInterval(step, 120); }};
  document.getElementById('stopBtn').onclick = ()=>{ if(running){ running = false; clearInterval(interval); interval = null;} };
  document.getElementById('randomBtn').onclick = clusterSpawn;
  document.getElementById('clearBtn').onclick = clearGrid;

  sizeRange.oninput = e=>{ sizeLbl.textContent = e.target.value; };
  sizeRange.onchange = e=> resizeGrid(parseInt(e.target.value,10));
  reproProb.oninput = e=>{ reproProbVal.textContent = e.target.value; };
  sharpness.oninput = e=>{ sharpVal.textContent = e.target.value; };
  starBias.oninput = e=>{ starBiasVal.textContent = e.target.value; };
  freezeDepth.oninput = e=>{ freezeVal.textContent = e.target.value; };
  for(let i=0;i<5;i++){
    document.getElementById('p'+i).oninput = e => document.getElementById('p'+i+'v').textContent = e.target.value;
    document.getElementById('c'+i).oninput = e => document.getElementById('c'+i+'v').textContent = e.target.value;
  }

  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect(); const cx = Math.floor((ev.clientX - rect.left) / cellSize); const cy = Math.floor((ev.clientY - rect.top) / cellSize);
    if(!inBounds(cx,cy)) return; grid[cy][cx] = (grid[cy][cx] + 1) % 6; draw();
  });

  resizeGrid(100); clusterSpawn();

})();
</script>
</body>
</html>
